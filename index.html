<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Seasonal Birthday Tree — Happy Birthday Grandpa</title>
<style>
  :root{
    --stage-w: 1200px;
    --bg-dark: #07142a;
    --final-bg: linear-gradient(180deg,#041423,#07243a);
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;color:#fff;background:var(--bg-dark);}
  .wrap{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:18px;}
  .card{width:min(1100px,96vw);height:min(720px,86vh);border-radius:12px;overflow:hidden;position:relative;box-shadow:0 18px 60px rgba(0,0,0,0.6);}
  /* four quadrant backgrounds (images you provide) */
  .grid{position:absolute;inset:0;display:grid;grid-template-columns:1fr 1fr;grid-template-rows:1fr 1fr;}
  .cell{position:relative;overflow:hidden;border:1px solid rgba(255,255,255,0.02)}
  .spring{ background: center/cover no-repeat url('spring.png'); background-color:#dff7e2; }
  .summer{ background: center/cover no-repeat url('summer.png'); background-color:#ffedd8; }
  .autumn{ background: center/cover no-repeat url('autumn.png'); background-color:#fff0e0; }
  .winter{ background: center/cover no-repeat url('winter.png'); background-color:#eaf6ff; }

  /* overlay canvas (one canvas to draw all 4 trees) */
  canvas#scene{position:absolute;inset:0;width:100%;height:100%;display:block;z-index:2}

  /* top UI */
  .ui{position:absolute;left:12px;top:12px;z-index:6;display:flex;gap:8px}
  button{padding:8px 12px;border-radius:10px;border:0;background:linear-gradient(180deg,#0d6d9a,#044a6b);color:white;cursor:pointer;box-shadow:0 6px 14px rgba(0,0,0,0.4)}
  .small{color:rgba(255,255,255,0.85);font-size:13px;margin-left:8px;align-self:center}

  /* final birthday screen */
  .final{position:absolute;inset:0;z-index:10;display:flex;align-items:center;justify-content:center;flex-direction:column;gap:18px;opacity:0;pointer-events:none;transition:opacity 900ms ease;}
  .final.show{opacity:1;pointer-events:auto}
  .final .moon{width:160px;height:160px;border-radius:50%;position:relative;box-shadow:0 0 40px 20px rgba(255,250,230,0.06), inset -14px -6px 40px rgba(0,0,0,0.12); background:radial-gradient(circle at 36% 30%, rgba(255,255,245,0.98), rgba(255,255,245,0.85) 35%, rgba(255,255,245,0.0) 70%); transform:translateY(-24px)}
  .final h1{font-size:clamp(28px,4.5vw,56px);color:#dff7ff;text-shadow:0 0 18px rgba(121,198,255,0.45), 0 6px 30px rgba(0,0,0,0.6)}
  .final .glow{font-weight:800;letter-spacing:1px;color:#dff7ff;text-shadow:0 0 10px rgba(121,198,255,0.8), 0 10px 30px rgba(3,18,30,0.6);font-size:clamp(22px,3vw,36px);}

  /* small credits */
  .footer{position:absolute;right:12px;bottom:10px;z-index:6;color:rgba(255,255,255,0.7);font-size:12px}
</style>
</head>
<body>
  <div class="wrap">
    <div class="card" role="application" aria-label="Seasonal Birthday Tree App">
      <div class="grid" aria-hidden="true">
        <div class="cell spring" data-season="spring"></div>
        <div class="cell summer" data-season="summer"></div>
        <div class="cell autumn" data-season="autumn"></div>
        <div class="cell winter" data-season="winter"></div>
      </div>

      <canvas id="scene" aria-label="Animated seasonal trees"></canvas>

      <div class="ui">
        <button id="replay">Replay</button>
        <span class="small">Seasonal trees grow automatically on load</span>
      </div>

      <div class="final" id="finalScreen" aria-hidden="true">
        <div class="moon" aria-hidden="true"></div>
        <h1 class="glow">Happy Birthday, Grandpa</h1>
        <div style="color:#cfefff;opacity:0.95">Wishing you calm days and warm smiles.</div>
      </div>

      <div class="footer">Made with ♥ — Spark & Nova</div>
    </div>
  </div>

<script>
/* --------------------
  Seasonal Trees demo
  - Single canvas divided into 4 regions
  - Each region grows a natural tree (recursive rules)
  - Leaves/hearts are drawn with variations (size, rotation, color)
  - Autumn has falling hearts, Winter has snow
  - All trees grow simultaneously; after ~29s show final message
-------------------- */

const canvas = document.getElementById('scene');
const ctx = canvas.getContext('2d', { alpha: true });
let DPR = Math.max(1, window.devicePixelRatio || 1);

function resize() {
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.round(rect.width * DPR);
  canvas.height = Math.round(rect.height * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
  layout = rect; // store for partitions
}
window.addEventListener('resize', resize);
resize();

/* timeline (ms) */
const TIMINGS = {
  branchGrow: 18000,  // draw branches progressively
  leavesBloom: 6000,  // reveal leaves/hearts
  afterPause: 1200,   // small pause
  fadeToFinal: 1200   // final fade (trigger)
};
const TOTAL = TIMINGS.branchGrow + TIMINGS.leavesBloom + TIMINGS.afterPause + TIMINGS.fadeToFinal; // ~29.4s

/* Quadrant definitions (calc from canvas size) */
function quadRects() {
  const w = canvas.width / DPR, h = canvas.height / DPR;
  const halfW = w/2, halfH = h/2;
  return {
    spring: {x:0, y:0, w:halfW, h:halfH},
    summer: {x:halfW, y:0, w:halfW, h:halfH},
    autumn: {x:0, y:halfH, w:halfW, h:halfH},
    winter: {x:halfW, y:halfH, w:halfW, h:halfH}
  };
}

/* Utility: cubic bezier point at t */
function cubicAt(p0,p1,p2,p3,t){
  const u=1-t; const tt=t*t; const uu=u*u; const uuu=uu*u; const ttt=tt*t;
  const x = uuu*p0.x + 3*uu*t*p1.x + 3*u*tt*p2.x + ttt*p3.x;
  const y = uuu*p0.y + 3*uu*t*p1.y + 3*u*tt*p2.y + ttt*p3.y;
  return {x,y};
}

/* Generate branch structure recursively.
   Each branch is represented by an object:
   {p0, p1, p2, p3, thickness, depth, children: [...], points: [...]}
   Points will be sampled along bezier to animate partial drawing.
*/
function generateBranch(start, angle, length, depth, maxDepth, thickness, spread){
  // end point
  const rad = angle * Math.PI/180;
  const ex = start.x + Math.cos(rad) * length;
  const ey = start.y + Math.sin(rad) * length;
  // control points to make a nice curve (randomized slightly for natural look)
  const cp1 = {
    x: start.x + Math.cos(rad - 0.35) * (length * (0.35 + Math.random()*0.2)),
    y: start.y + Math.sin(rad - 0.35) * (length * (0.35 + Math.random()*0.2))
  };
  const cp2 = {
    x: start.x + Math.cos(rad + 0.35) * (length * (0.6 + Math.random()*0.2)),
    y: start.y + Math.sin(rad + 0.35) * (length * (0.6 + Math.random()*0.2))
  };
  const branch = {
    p0: {x:start.x, y:start.y},
    p1: cp1,
    p2: cp2,
    p3: {x:ex, y:ey},
    thickness,
    depth,
    children: []
  };
  // sample points along this bezier for smooth progressive drawing
  const samples = Math.max(10, Math.round(14 + length / 8));
  branch.points = [];
  for(let i=0;i<=samples;i++){
    const t = i/samples;
    branch.points.push(cubicAt(branch.p0,branch.p1,branch.p2,branch.p3,t));
  }

  // branching condition
  if(depth < maxDepth){
    // decide number of children (1-3) biased by depth
    const chance = Math.random();
    const num = chance < 0.2 ? 1 : (chance < 0.9 ? 2 : 3);
    for(let i=0;i<num;i++){
      // child angle deviates
      const angDelta = (Math.random()*spread - spread/2) + (i - (num-1)/2) * (10 + Math.random()*6);
      const newAngle = angle + angDelta;
      const newLen = length * (0.58 + Math.random()*0.18);
      const newThick = Math.max(0.8, thickness * (0.6 + Math.random()*0.12));
      branch.children.push(generateBranch(branch.p3, newAngle, newLen, depth+1, maxDepth, newThick, spread));
    }
  }
  return branch;
}

/* Create tree structure for a quadrant */
function createTreeFor(rect, season){
  // root starting point somewhere near bottom center of rect
  const baseX = rect.x + rect.w*0.5;
  const baseY = rect.y + rect.h*0.92;
  // parameters tuned per season for look
  const maxDepth = 4; // controls complexity
  const trunkLen = rect.h * 0.28;
  const trunkThickness = Math.max(6, rect.w * 0.014);
  // generate trunk as a main bezier
  const trunk = generateBranch({x:baseX,y:baseY}, -90, trunkLen, 0, 1, trunkThickness, 18);
  // attach branches recursively to trunk tip
  const canopyDepth = maxDepth;
  // create primary branches from trunk tip
  const children = [];
  const mainAngles = [-85,-95,-60,-120]; // slightly varied
  for(let i=0;i<4;i++){
    const ang = mainAngles[i] + (Math.random()*12-6);
    const len = trunkLen * (0.9 * (0.8 + Math.random()*0.5));
    children.push(generateBranch(trunk.p3, ang, len, 1, canopyDepth, trunkThickness*0.66, 46));
  }
  trunk.children = trunk.children.concat(children);

  // additional small clusters near trunk
  // recursively expand children deeper using a helper to flatten counts
  function attachRandom(node, depthLeft){
    if(depthLeft<=0) return;
    const decide = Math.random();
    if(decide>0.45 && node.depth < canopyDepth){
      const ang = -90 + (Math.random()*140 - 70);
      const len = trunkLen * (0.5 + Math.random()*0.6) * Math.pow(0.7, node.depth);
      node.children.push(generateBranch(node.p3, ang, len, node.depth+1, canopyDepth, node.thickness*0.6, 50));
    }
    node.children.forEach(ch => attachRandom(ch, depthLeft-1));
  }
  attachRandom(trunk, 3);

  return {root:trunk, rect, season};
}

/* flatten tree branches into an ordered array for progressive drawing */
function flattenBranches(node, list=[]){
  list.push(node);
  node.children.forEach(ch => flattenBranches(ch, list));
  return list;
}

/* draw a single branch up to given progress ratio (0..1)
   we use branch.points to draw up to idx
*/
function drawBranchProgress(branch, progress, colorBase){
  const pts = branch.points;
  const n = pts.length;
  const upto = Math.floor(progress * (n-1));
  if(upto<=0){
    // draw nothing except maybe a tiny dot at start
    return;
  }
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  // subtle color based on depth for layering (back darker)
  const shade = (branch.depth || 0);
  const r = colorBase.r, g=colorBase.g, b=colorBase.b;
  const alpha = 0.95 - Math.min(0.5, (branch.depth||0)*0.12);
  ctx.strokeStyle = `rgba(${r},${g},${b},${alpha})`;
  ctx.lineWidth = Math.max(0.6, branch.thickness);
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  for(let i=1;i<=upto;i++){
    ctx.lineTo(pts[i].x, pts[i].y);
  }
  ctx.stroke();
}

/* draw heart shape at (x,y) ; scale controls size */
function drawHeart(x,y,scale, color){
  ctx.save();
  ctx.translate(x,y);
  ctx.scale(scale,scale);
  ctx.beginPath();
  // simple heart path using bezier curves relative to origin
  ctx.moveTo(0,-8);
  ctx.bezierCurveTo(-8,-8, -8,-18, 0,-20);
  ctx.bezierCurveTo(8,-18, 8,-8, 0,-8);
  ctx.closePath();
  ctx.fillStyle = color;
  // slight shadow / glow
  ctx.shadowColor = 'rgba(0,0,0,0.18)';
  ctx.shadowBlur = 6;
  ctx.fill();
  ctx.restore();
  ctx.shadowBlur = 0;
}

/* draw a small leaf (oval) for winter snow fallback if needed */
function drawSnowflake(x,y, size){
  ctx.save();
  ctx.translate(x,y);
  ctx.fillStyle = 'rgba(255,255,255,0.95)';
  ctx.beginPath();
  ctx.arc(0,0,size/2,0,Math.PI*2);
  ctx.fill();
  ctx.restore();
}

/* season palettes and behaviors */
const SEASONS = {
  spring: {
    leafColor: (i)=> `rgba(86, 183, 107, ${0.95 - Math.random()*0.12})`, // greens
    leafScale: ()=> 0.9 + Math.random()*0.6,
    falling:false, extraDraw: function(ctx, rect, t) { /* tiny flowers at ground */ }
  },
  summer: {
    leafColor: (i)=> `rgba(${230+Math.random()*10|0}, ${90+Math.random()*40|0}, ${40+Math.random()*30|0}, ${0.98 - Math.random()*0.08})`, // warm orange/red
    leafScale: ()=> 0.95 + Math.random()*0.6,
    falling:false,
    extraDraw: function(ctx, rect, t){
      // draw a warm sun in top-right of summer quadrant
      const sunX = rect.x + rect.w*0.85, sunY = rect.y + rect.h*0.14, R = Math.min(rect.w,rect.h)*0.12;
      const grd = ctx.createRadialGradient(sunX, sunY, R*0.2, sunX, sunY, R*2);
      grd.addColorStop(0, 'rgba(255,230,170,0.95)');
      grd.addColorStop(1, 'rgba(255,175,65,0.06)');
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.arc(sunX, sunY, R*1.4, 0, Math.PI*2);
      ctx.fill();
    }
  },
  autumn: {
    leafColor: (i)=> `rgba(${220+Math.random()*20|0}, ${120+Math.random()*30|0}, ${40+Math.random()*20|0}, ${0.95 - Math.random()*0.12})`,
    leafScale: ()=> 0.95 + Math.random()*0.55,
    falling:true
  },
  winter: {
    leafColor: ()=> null,
    leafScale: ()=> 0.7,
    falling:true, // snow
  }
};

/* Build trees for each quadrant */
let trees = null;
function buildTrees(){
  const rects = quadRects();
  trees = {
    spring: createTreeFor(rects.spring, 'spring'),
    summer: createTreeFor(rects.summer, 'summer'),
    autumn: createTreeFor(rects.autumn, 'autumn'),
    winter: createTreeFor(rects.winter, 'winter'),
  };
  // flatten branches per tree
  for(const k in trees){
    const root = trees[k].root;
    trees[k].branches = flattenBranches(root, []);
    // create leaf slots (branch endpoints where children length==0 or small)
    trees[k].leaves = [];
    trees[k].branches.forEach(b=>{
      // endpoint is p3
      if(b.children.length===0 || b.depth >= 3){
        trees[k].leaves.push({x:b.p3.x + (Math.random()*8-4), y:b.p3.y + (Math.random()*8-4), scale: (SEASONS[k].leafScale()), drawn:false});
      } else {
        // also sometimes add leaves along longer branches
        if(Math.random() > 0.7) trees[k].leaves.push({x:b.p3.x + (Math.random()*12-6), y:b.p3.y + (Math.random()*12-6), scale: (SEASONS[k].leafScale()), drawn:false});
      }
    });
    // some tuning: winter has no leaves
    if(k==='winter'){
      trees[k].leaves = []; // bare
    }
    // autumn falling particle list
    trees[k].falling = [];
  }
}

/* Animation state */
let startTime = null;
let raf = null;

/* Main draw loop */
function drawFrame(ts){
  if(!startTime) startTime = ts;
  const elapsed = (ts - startTime);
  // clear
  ctx.clearRect(0,0,canvas.width/DPR, canvas.height/DPR);

  // per-tree drawing
  const rects = quadRects();
  const keys = ['spring','summer','autumn','winter'];
  keys.forEach(key=>{
    const tree = trees[key];
    const rect = rects[key];
    // clip to quadrant so drawings don't bleed
    ctx.save();
    ctx.beginPath();
    ctx.rect(rect.x, rect.y, rect.w, rect.h);
    ctx.clip();

    // seasonal extra drawings (sun etc)
    if(SEASONS[key].extraDraw) SEASONS[key].extraDraw(ctx, rect, elapsed);

    // compute branch drawing progress: 0..1 over TIMINGS.branchGrow
    const branchProg = Math.min(1, elapsed / TIMINGS.branchGrow);
    // leaves bloom starts after branchProg full: leavesProg 0..1 across TIMINGS.leavesBloom
    const leavesStart = TIMINGS.branchGrow;
    const leavesProg = Math.max(0, Math.min(1, (elapsed - leavesStart) / TIMINGS.leavesBloom));

    // draw branches in order (back to front): we already flattened in pre-order; to give depth, draw deeper first
    const branches = tree.branches.slice().sort((a,b)=> (a.depth - b.depth)); // shallow first or deep first? choose deep first
    branches.forEach(br=>{
      // compute per-branch local progress (slight staggering using branch index)
      const idx = tree.branches.indexOf(br);
      // small offset so branches don't all draw at same instant
      const localDelay = (idx % 6) * 60; // milliseconds staggering
      const localProg = Math.max(0, Math.min(1, (elapsed - localDelay) / TIMINGS.branchGrow));
      // color base for bark (brownish)
      const colorBase = {r:110, g:69, b:51};
      drawBranchProgress(br, localProg, colorBase);
    });

    // draw leaves/hearts according to leavesProg
    const leaves = tree.leaves;
    leaves.forEach((leaf, i)=>{
      // each leaf has its own pop delay
      const popDelay = i * 80 + 200; // stagger
      const lp = Math.max(0, Math.min(1, (elapsed - TIMINGS.branchGrow - popDelay) / (TIMINGS.leavesBloom - popDelay)));
      if(lp > 0){
        // ease
        const ease = Math.sin(lp * Math.PI * 0.5);
        // position slightly jitter for "pop"
        const x = leaf.x + (1 - lp) * (Math.random()*6 - 3);
        const y = leaf.y + (1 - lp) * (Math.random()*6 - 3);
        // seasonal color
        const color = (SEASONS[key].leafColor && SEASONS[key].leafColor(i)) || 'rgba(255,255,255,0.95)';
        const sc = leaf.scale * (0.5 + ease*1.2);
        // some rotation based on i and key for natural look: (we use transform via saved canvas)
        ctx.save();
        ctx.translate(x,y);
        ctx.rotate((i%7 - 3) * 0.06 * (1-lp));
        ctx.translate(-x,-y);
        drawHeart(x,y, sc, color);
        ctx.restore();

        // mark drawn
        leaf.drawn = leaf.drawn || lp > 0.05;
      }
    });

    // seasonal falling behavior (autumn hearts, winter snow)
    if(tree && (SEASONS[key].falling)){
      if(key === 'autumn'){
        // spawn some falling hearts after leavesProg>0.2
        if(leavesProg > 0.25 && Math.random() < 0.03){
          // pick random leaf origin
          const src = tree.leaves[Math.floor(Math.random()*Math.max(1,tree.leaves.length))];
          if(src){
            tree.falling.push({
              x: src.x + (Math.random()*20-10),
              y: src.y,
              vx: (Math.random()*1-0.5),
              vy: 0.6 + Math.random()*0.6,
              rot: Math.random()*6,
              size: 0.9 + Math.random()*0.9,
              color: SEASONS[key].leafColor()
            });
          }
        }
        // update & draw falling hearts
        for(let i=tree.falling.length-1;i>=0;i--){
          const p = tree.falling[i];
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.02; // gravity
          p.rot += 0.03;
          ctx.save();
          ctx.translate(p.x,p.y);
          ctx.rotate(p.rot);
          drawHeart(0,0, p.size, p.color);
          ctx.restore();
          // remove if off-canvas
          if(p.y > rect.y + rect.h + 30) tree.falling.splice(i,1);
        }
      } else if(key === 'winter'){
        // spawn snow continuously after branch drawn slightly
        if(Math.random() < 0.08){
          tree.falling.push({
            x: rect.x + Math.random()*rect.w,
            y: rect.y - 10,
            vx: (Math.random()*0.4-0.2),
            vy: 0.4 + Math.random()*0.4,
            size: 2 + Math.random()*3
          });
        }
        for(let i=tree.falling.length-1;i>=0;i--){
          const p = tree.falling[i];
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.002;
          ctx.save();
          drawSnowflake(p.x, p.y, p.size);
          ctx.restore();
          if(p.y > rect.y + rect.h + 20) tree.falling.splice(i,1);
        }
      }
    }

    ctx.restore(); // quadrant clip
  }); // end keys.forEach

  // loop or finish
  if(elapsed < TOTAL){
    raf = requestAnimationFrame(drawFrame);
  } else {
    // finish: transition to final screen
    showFinal();
  }
}

/* show final birthday screen (fade overlay) */
function showFinal(){
  const fin = document.getElementById('finalScreen');
  fin.classList.add('show');
  // optional: animate mild moon glow pulses
}

/* build & start */
function startAnimation(){
  cancelAnimationFrame(raf);
  startTime = null;
  // rebuild trees for current canvas size
  buildTrees();
  raf = requestAnimationFrame(drawFrame);
}

/* button wiring */
document.getElementById('replay').addEventListener('click', ()=>{
  // hide final screen if visible
  document.getElementById('finalScreen').classList.remove('show');
  // reset any particles
  for(const k in trees) if(trees[k]) trees[k].falling = [];
  // restart timeline
  startAnimation();
});

/* initialize */
buildTrees();
startAnimation();

/* adjust on resize (rebuild) */
let resizeTimer = null;
window.addEventListener('resize', ()=>{
  clearTimeout(resizeTimer);
  resize();
  resizeTimer = setTimeout(()=>{
    buildTrees();
    startAnimation();
  }, 220);
});
</script>
</body>
</html>
